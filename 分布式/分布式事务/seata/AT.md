基本原理：
两阶段提交协议的演变：
- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：
    - 提交异步化，非常快速地完成。
    - 回滚通过一阶段的回滚日志进行反向补偿。
问题：很明显可以看出上面2阶段有个大问题，就是多个事务操作同一数据时，可能会出现脏写，出现这种情况便不能回滚1阶段提交的事务。
    - 举例：事务1 对用户A进行扣款 account= 1000 - 100 ，1阶段开始提交，after image （account = 900）
    - 事务2也对用户A进行扣款 account = 900 - 60，还未提交事务，现在事务1需要回滚（当前account = 840 不等于 900所以不能进行事务1的回滚操作）
    - 造成这种情况的根本原因是at模式不能保证事务的隔离性。（加全局锁不会出现这种情况）

优点：简单，业务代码无侵入，seata @globalTransactional

缺点：上面说了，不保证隔离性

解决方案：协调者和参与者都添加重试和超时机制（锁超时默认5s，网络连接超时和获取锁的超时）
  如果业务场景中的事务处理较为复杂，可以适当增加全局锁等待超时时间；如果对于数据一致性要求较高或者资源利用率要求较高，可以适当减少全局锁等待超时时间。


完整的执行流程：
  1阶段将业务数据和after image以及before image都写入业务数据库，直接提交事务
  2阶段根据与协调者的沟通判断是叫全局事务状态改为ok还是回滚或者参与者跟协调者之间失联。
      如果是ok则定时定理ok状态的undo log
      如果是回滚，则判断after image与当前数据是否一致（这个地方可以通过全局锁来保证事务隔离性），然后还原before image
      如果是失联，则等到超时时间结束后回滚所有分支事务
